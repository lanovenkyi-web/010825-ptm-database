Оконные функции в SQL можно разделить на несколько категорий в зависимости от того, какие задачи они решают. 
Вот основные виды оконных функций:

## 1. АГРЕГАТНЫЕ оконные функции

    Эти функции выполняют агрегатные операции (суммирование, подсчёт среднего и т.д.)
    по окну строк, которое вы задаёте с помощью OVER(). В отличие от обычных
    агрегатных функций, здесь результат сохраняется для каждой строки.

Примеры:

- `SUM()` — сумма значений
- `AVG()` — среднее значение 
- `MIN()` — минимальное значение
- `MAX()` — максимальное значение
- `COUNT()` — количество строк
-  `GROUP_CONCAT` - конкатенация строковых значений

Пример: 
```
SELECT first_name, last_name, department_id, salary,
       SUM(salary) OVER (PARTITION BY department_id) AS department_salary_sum
FROM hr.employees;
```

## 2. РАНЖИРУЮЩИЕ (ranking) функции

    Ранжирующие функции присваивают каждой строке номер или ранг
    в зависимости от её положения в окне.

Примеры:

- `ROW_NUMBER()` — порядковый номер строки в окне.
- `RANK()` — присваивает ранг строкам в окне, одинаковые значения получают одинаковый ранг, а следующий ранг пропускается (например, 1, 2, 2, 4).
- `DENSE_RANK()` — аналогично `RANK()`, но без пропусков (например, 1, 2, 2, 3).
- `NTILE(n)` — делит строки окна на n равных част (например, n = 3 для 6 строк: 1, 1, 2, 2, 3, 3).

```
-- ранжирование зарплат по всей таблице
SELECT 
    first_name, last_name, salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM 
    employees;

-- аналогично с разбивкой по каждому департаменту в отдельности
SELECT 
    first_name, last_name, salary,
    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
FROM 
    employees;

-- весь диапазон окна разбит на 4 (приблизительно) равные части
SELECT 
    first_name, last_name, department_id, salary,
    NTILE(4) OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_quartile
FROM 
    employees;
```

## 3. Функции СМЕЩЕНИЯ (аналоги лагов и лидов)

    Эти функции позволяют получать значения строк, которые находятся
    на определённой позиции относительно текущей строки.

Примеры:

- `LAG()` — возвращает значение предыдущей строки в окне.
- `LEAD()` — возвращает значение следующей строки в окне.
- `FIRST_VALUE()` — возвращает первое значение в окне.
- `LAST_VALUE()` — возвращает последнее значение в окне.
- `NTH_VALUE(n)` — возвращает n-ное значение в окне.

```
SELECT 
    first_name, last_name, salary,
    LAG(salary, 1) OVER (ORDER BY salary) AS previous_salary
FROM employees;
```

| Функция             | Назначение                                        | Синтаксис (общий)                                           | Что делает при вызове с 1 аргументом                                                |
|---------------------| ------------------------------------------------- | ----------------------------------------------------------- |-------------------------------------------------------------------------------------|
| **`LAG()`**         | Возвращает значение **предыдущей строки** в окне  | `LAG(expr [, offset [, default_value]]) OVER (...)`         | `LAG(field)` = значение поля из **предыдущей строки** (или `NULL`, если строки нет) |
| **`LEAD()`**        | Возвращает значение **следующей строки** в окне   | `LEAD(expr [, offset [, default_value]]) OVER (...)`        | `LEAD(field)` = значение поля из **следующей строки** (или `NULL`, если строки нет) |
| **`FIRST_VALUE()`** | Возвращает **первое значение** в пределах окна    | `FIRST_VALUE(expr) OVER ([PARTITION BY ...] ORDER BY ...)`  | `FIRST_VALUE(field)` = значение первой строки окна (по текущему `ORDER BY`)         |
| **`LAST_VALUE()`**  | Возвращает **последнее значение** в пределах окна | `LAST_VALUE(expr) OVER ([PARTITION BY ...] ORDER BY ...)`   | ⚠️ Без `frame` возвращает **текущее значение**, а не «последнее»                     |
| **`NTH_VALUE(n)`**  | Возвращает **n-тое значение** из окна             | `NTH_VALUE(expr, n) OVER ([PARTITION BY ...] ORDER BY ...)` | `NTH_VALUE(field, 2)` = второе значение в порядке сортировки                        |

где

* `expr`— любое выражение (чаще всего имя поля) 
* `offset` — на сколько строк сдвинуться (вперёд или назад) (по умолчанию 1)
* `default_value`- что вернуть, если строки нет (по умолчанию `NULL`)
* `n` - какое по счёту значение вернуть (указывается вручную)
* `frame` - по умолчанию `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

---

## 4. ФРЕЙМЫ (frames)

    Фреймы позволяют задавать конкретные диапазоны строк в пределах окна,
    для которых будет выполняться вычисление. Эти функции более тонко
    настраиваются с помощью ключевых слов, таких как `ROWS` и `RANGE`,
    и позволяют ограничить количество строк, учитываемых для расчёта.

- `ROWS BETWEEN` — указывает диапазон строк относительно текущей строки.
- `RANGE BETWEEN` — похож на ROWS, но работает с диапазоном значений, а не с конкретными строками.

Для указания диапазона строк окна возможны следующие варианты:

- `UNBOUNDED PRECEDING`	    - Все строки от начала набора данных
- `N PRECEDING`	            - N строк до текущей строки (или значение)
- `CURRENT ROW`	            - Текущая строка (значение текущей строки)
- `N FOLLOWING`	            - N строк после текущей строки (или значение)
- `UNBOUNDED FOLLOWING`	    - Все строки от текущей строки до конца набора данных


**Фрейм по умолчанию**: `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

Примеры:

В этом запросе вычисляется сумма зарплаты между одно предыдущей строкой и одной следующей
```
SELECT 
    first_name, last_name, salary,
    SUM(salary) OVER (ORDER BY salary ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS moving_sum
FROM 
    employees;
```
А здесь считается кумулятивная (накопительная) сумма возрастающим итогом по каждой строке в таблице, предварительно отсортированной по зарплате
```
SELECT 
    first_name, last_name, salary,
    SUM(salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum
FROM 
    employees;
```

Следует обращать внимание, что `ROWS` учитывает строки относительно текущей, а `RANGE` - значения строк относительно значения текущей.

Например:
```
SELECT
	salary,
	SUM(salary) OVER(ORDER BY salary RANGE BETWEEN CURRENT ROW AND 3000 FOLLOWING)
FROM 
    (SELECT * FROM hr.employees LIMIT 5) AS t;

RANGE означает: суммировать строки, где ЗП в диапазоне от текущей до текущая + 3000
------------------------------------------------------------------------------------------------
  salary    SUM(salary)     ДИАПАЗОН salary RANGE BETWEEN CURRENT ROW AND 3000 FOLLOWING означает
'6000.00',  '15000.00'      от 6 000 до 9 000
'9000.00',  '9000.00'       от 9 000 до 12 000
'17000.00', '34000.00'      от 17 000 до 20 000
'17000.00', '34000.00'      от 17 000 до 20 000
'24000.00', '24000.00'      от 24 000 до 24 000
---------------------------------------------------------------------------------------------- 

SELECT
	salary,
	SUM(salary) OVER(ORDER BY salary ROWS BETWEEN CURRENT ROW AND 3000 FOLLOWING)
FROM 
    (SELECT * FROM hr.employees LIMIT 5) AS t;

------------------------------------------------------------------------------------------------
  salary     SUM(salary)    ДИАПАЗОН salary ROWS BETWEEN CURRENT ROW AND 3000 FOLLOWING означает:
'6000.00',  '73000.00'      от текущей строки до 3000 последующих строк
'9000.00',  '67000.00'      от текущей строки до 3000 последующих строк
'17000.00', '58000.00'      от текущей строки до 3000 последующих строк
'17000.00', '41000.00'      от текущей строки до 3000 последующих строк
'24000.00', '24000.00'      от текущей строки до 3000 последующих строк */
------------------------------------------------------------------------------------------------

RANGE очень удобно использовать для дат, когда требуется получить "скользящий" итог.
В следующем примере мы получаем итог продаж за каждые 2 месяца: текущий и предшествующий: */

SELECT DISTINCT
    MONTH(ODATE) AS month_,
    SUM(AMT) OVER(PARTITION BY MONTH(ODATE)) AS month_sales,
    SUM(AMT) OVER (
        ORDER BY ODAtE
        RANGE BETWEEN INTERVAL 1 MONTH PRECEDING AND CURRENT ROW
    ) AS rolling_2_month_sales
FROM
    shop.ORDERS
ORDER BY
    ODATE;

------------------------------------------------------------------------------------------------
month,  month_sales,    rolling_2_month_sales
3       12944.59,       12944.59
4        1788.98,       14733.57
5        4723.00,        6511.98
6       11201.83,       15924.83
------------------------------------------------------------------------------------------------
```

## 5. СУММАРНЫЕ и КУМУЛЯТИВНЫЕ функции

Агрегатные функции становятся кумулятивными, когда используются с окном c сортировкой OVER(ORDER BY ...):

- `SUM()` — кумулятивная сумма.
- `AVG()` — кумулятивное среднее.
- `COUNT()` — кумулятивное количество.
- `MIN()` — кумулятивный минимум.
- `MAX()` — кумулятивный максимум.

Специфические оконные функции, которые вычисляют кумулятивные характеристики:

- `CUME_DIST()` — кумулятивное распределение (доля строк с меньшим или равным значением).
- `PERCENT_RANK()` — процентный ранг строки в окне.

Пример:
```
SELECT 
    first_name, last_name, salary,
    CUME_DIST() OVER (ORDER BY salary) AS salary_distribution
FROM 
    employees;
```
Заключение:

- **Агрегатные оконные функции** — для вычисления суммы, среднего, количества и других агрегатов.
- **Ранжирующие функции** — для присвоения строкам номеров или рангов.
- **Функции смещения** — для доступа к соседним строкам.
- **Функции фреймов** — для более гибкой работы с диапазонами строк.
- **Кумулятивные функции** — для вычисления накопительных и процентных значений.

Эти оконные функции позволяют решать широкий круг задач, связанных с аналитикой данных,  
без необходимости группировать строки и тем самым терять исходные данные.
